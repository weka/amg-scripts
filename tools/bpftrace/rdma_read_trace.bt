#!/usr/bin/env bpftrace
/*
 * Copyright 2025 Serapheim Dimitropoulos <serapheim.dimitropoulos@weka.io>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * For reference here is what the RDMA IOCTL arg looks like:
 * ```
 * struct RDMADesc {
 *   align(1):
 *   int32_t   op;
 *   uint64_t  descSize;
 *   char[256] desc;
 *   uint64_t  off;
 *   uint64_t  size;
 *   uint64_t  actualSize;
 *   uint64_t  rdmaOff;
 * };
 *   static assert (RDMADesc.sizeof == 300);
 * ```
 * Given that sometimes we will lack BTF information, this
 * script accesses these fields with pointer arithmentic
 * in the offsets of the fields (keep in mind that the
 * structure is also "packed").
 *
 * Explaination of each field:
 * > op         - operation type
 * > descSize   - length of descriptor string
 * > desc       - GPU memory registration info string
 * > off        - file offset to read/write from
 * > size       - number of bytes requested
 * > actualSize - ignored by kernel (this is output only)
 * > rdmaOff    - offset within GPU buffer
 * ```
 *
 * Other related IOCTL info:
 * ```
 * #define IOCTL_RDMA (('R' << 24) | ('D' << 16) | ('M' << 8) | 'A')
 * // ^ evaluates to 0x52444D41 or 1380208961.
 * ```
 */

#define IOCTL_RDMA 0x52444d41
#define RDMA_READ_OP 0
#define RDMA_WRITE_OP 1
#define TARGET_DIR "/mnt/weka/serapheim-cache/"
#define TARGET_DIR_STR_LEN 26


BEGIN
{
	printf("Tracing operations on files in: %s\n", TARGET_DIR);
}

tracepoint:syscalls:sys_enter_openat
{
	@path[tid] = args->filename;
        @open_start[tid] = nsecs;
}

tracepoint:syscalls:sys_exit_openat
/@path[tid]/
{
	// A return value > 0 is a valid file descriptor.
	if (args->ret > 0) {
		$path = str(@path[tid]);

		// Check if the path is in our target directory.
		if (strncmp($path, TARGET_DIR, TARGET_DIR_STR_LEN) == 0) {
			$fd = args->ret;
			$elapsed_us = (nsecs - @open_start[tid]) / 1000;
			printf("-> (%lu) Tracking new file: %s (pid: %d, tid:%d, fd: %d) - openat() took %d us\n",
                               nsecs / 1000, $path, pid, tid, $fd, $elapsed_us);

			@tracked_fds[pid, $fd] = 1;
			@tracked_paths[pid, $fd] = $path;
			@op_start[pid, $fd] = @open_start[tid];
		}
	}

	delete(@path[tid]);
        delete(@open_start[tid]);
}

tracepoint:syscalls:sys_enter_ioctl
/@tracked_fds[pid, args->fd] && args->cmd == IOCTL_RDMA/
{
        $op = *(int32 *)((uint8 *)args->arg); // XXX: Explain why
        if ($op == RDMA_READ_OP) {
		$fd = args->fd;
		$path = @tracked_paths[pid, args->fd];
		$size = *(uint64 *)((uint8 *)args->arg + 276); // XXX: Explain why

		printf("    %lu pid:%d fd:%d tid:%d -> Issued read of %d bytes to %s\n",
                       nsecs / 1000, pid, tid, $fd, $size, $path);

		@read_ioctl_start[tid] = nsecs;
		@read_ioctl_size[tid] = $size;
		@read_ioctl_fd[tid] = $fd;
		@read_bytes[pid, $fd] += $size;
        }

	// Missed retprobes
	if (@path[tid]) {
		delete(@path[tid]);
		delete(@open_start[tid]);
	}
}

tracepoint:syscalls:sys_exit_ioctl
/@read_ioctl_start[tid]/
{
	$duration = (nsecs - @read_ioctl_start[tid]) / 1000;
	$fd = @read_ioctl_fd[tid];
	$path = @tracked_paths[pid, $fd];
	$size = @read_ioctl_size[tid];
	$ret = args->ret;

	printf("    %lu pid:%d tid:%d fd:%d <- Read of %d bytes to %s completed in %d us - retcode: %d\n",
               nsecs / 1000, pid, tid, $fd, $size, $path, $duration, $ret);

	delete(@read_ioctl_start[tid]);
	delete(@read_ioctl_size[tid]);
	delete(@read_ioctl_fd[tid]);
}

tracepoint:syscalls:sys_enter_close
/@tracked_fds[pid, args->fd]/
{
	$fd = args->fd;
	$path = @tracked_paths[pid, args->fd];

	@close_start[tid] = nsecs;
	@close_fd[tid] = $fd;
	@close_path[tid] = $path;
	@close_op_start[tid] = @op_start[pid, $fd];

	delete(@tracked_fds[pid, $fd]);
	delete(@tracked_paths[pid, $fd]);
	delete(@op_start[pid, $fd]);
}

tracepoint:syscalls:sys_exit_close
/@close_start[tid]/
{
	$fd = @close_fd[tid];
	$path = @close_path[tid];
        $close_us = (nsecs - @close_start[tid]) / 1000;
        $op_us = (nsecs - @close_op_start[tid]) / 1000;
	$total_read = @read_bytes[pid, $fd];

	if ($total_read != 0) {
		printf("<- (%lu) Untracking closed fd (pid: %d, tid: %d, fd: %d) - path %s - close() took %d us - overall op took %d us and issued a total of %d MiBs of reads\n",
		       nsecs / 1000, pid, tid, $fd, $path, $close_us, $op_us, $total_read >> 20);
		delete(@read_bytes[pid, $fd]);
	}

	delete(@close_start[tid]);
	delete(@close_fd[tid]);
	delete(@close_path[tid]);
	delete(@close_op_start[tid]);
}
