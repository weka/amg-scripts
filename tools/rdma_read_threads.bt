#!/usr/bin/env bpftrace
/*
 * Copyright 2025 Serapheim Dimitropoulos <serapheim.dimitropoulos@weka.io>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * For reference here is what the RDMA IOCTL arg looks like:
 * ```
 * struct RDMADesc {
 *   align(1):
 *   int32_t   op;
 *   uint64_t  descSize;
 *   char[256] desc;
 *   uint64_t  off;
 *   uint64_t  size;
 *   uint64_t  actualSize;
 *   uint64_t  rdmaOff;
 * };
 *   static assert (RDMADesc.sizeof == 300);
 * ```
 * Given that sometimes we will lack BTF information, this
 * script accesses these fields with pointer arithmentic
 * in the offsets of the fields (keep in mind that the
 * structure is also "packed").
 *
 * Explaination of each field:
 * > op         - operation type
 * > descSize   - length of descriptor string
 * > desc       - GPU memory registration info string
 * > off        - file offset to read/write from
 * > size       - number of bytes requested
 * > actualSize - ignored by kernel (this is output only)
 * > rdmaOff    - offset within GPU buffer
 * ```
 *
 * Other related IOCTL info:
 * ```
 * #define IOCTL_RDMA (('R' << 24) | ('D' << 16) | ('M' << 8) | 'A')
 * // ^ evaluates to 0x52444D41 or 1380208961.
 * ```
 */

#define IOCTL_RDMA 0x52444d41
#define RDMA_READ_OP 0
#define TARGET_DIR "/mnt/weka/cache/"
#define TARGET_DIR_STR_LEN 16

BEGIN
{
        printf("Tracing operations on files in: %s\n", TARGET_DIR);
}

tracepoint:syscalls:sys_enter_openat
{
        @path[pid, tid] = args->filename;
}

tracepoint:syscalls:sys_exit_openat
/@path[pid, tid]/
{
        // A return value > 0 is a valid file descriptor.
        if (args->ret > 0) {
                $path = str(@path[pid, tid]);

                // Check if the path is in our target directory.
                if (strncmp($path, TARGET_DIR, TARGET_DIR_STR_LEN) == 0) {
                        $fd = args->ret;
                        @tracked_fds[pid, $fd] = 1;

                        // Check if this is the first I/O for this Thread ID
                        if (!@thread_start[pid, tid]) {
                                @thread_start[pid, tid] = nsecs;
                        }
                }
        }
        delete(@path[pid, tid]);
}

tracepoint:syscalls:sys_enter_ioctl
/@tracked_fds[pid, args->fd] && args->cmd == IOCTL_RDMA/
{
        $op = *(int32 *)((uint8 *)args->arg); // op is the first operand of `arg`
        if ($op == RDMA_READ_OP) {
                $size = *(uint64 *)((uint8 *)args->arg + 276); // XXX: Explain why
                @read_ioctl_start[pid, tid] = nsecs;
                @tid_read_bytes[pid, tid] += $size;
                @tid_read_ops[pid, tid] += 1;
                @total_ops[pid] += 1;
                @total_read_bytes[pid] += $size;
        }

        // Missed retprobes
        if (@path[pid, tid]) {
                delete(@path[pid, tid]);
        }
}

tracepoint:syscalls:sys_exit_ioctl
/@read_ioctl_start[pid, tid]/
{
        $duration = (nsecs - @read_ioctl_start[pid, tid]);
        @tid_read_duration[pid, tid] += $duration / 1000;
        delete(@read_ioctl_start[pid, tid]);
}

tracepoint:syscalls:sys_enter_close
/@tracked_fds[pid, args->fd]/
{
        $fd = args->fd;
        @thread_duration[pid, tid] = (nsecs - @thread_start[pid, tid]) / 1000;
        delete(@tracked_fds[pid, $fd]);
}

interval:s:10 {
        printf("===START===\n");
        printf("Thread Read Ops\n");
        print(@tid_read_ops);
        printf("\nThread Read Durations\n");
        print(@tid_read_duration);
        printf("\nThread Bytes Read\n");
        print(@tid_read_bytes);
        printf("\nThread Execution Time\n");
        print(@thread_duration);
        printf("\nTotal Ops Per PID\n");
        print(@total_ops);
        printf("\nTotal Bytes Read\n");
        print(@total_read_bytes);
        printf("===END===\n");
}
